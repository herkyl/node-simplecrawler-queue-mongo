// Generated by CoffeeScript 1.10.0
(function() {
  var MongoQueue, ShortHostItem, _, getItem;

  _ = require("lodash");

  getItem = require("./QueueItem");

  ShortHostItem = require('./ShortHostItem');

  module.exports = MongoQueue = (function() {
    function MongoQueue(mongo, crawler) {
      var event, eventstates, query, setEventHandler, status;
      this.crawler = crawler;
      console.log("Initializing mongo queue for " + this.crawler.name);
      this.shortHosts = {};
      this.Item = getItem(mongo, this.crawler.name);
      this.updateStatus = function(item, status) {
        console.log(status + " \t " + item.url);
        item.set({
          status: status
        });
        return item.save(function(error) {
          if (error) {
            throw error;
          }
        });
      };
      eventstates = {
        fetchstart: 'spooled',
        fetchcomplete: 'fetched',
        fetcherror: 'error',
        fetchredirect: 'redirected'
      };
      setEventHandler = (function(_this) {
        return function(event, status) {
          return _this.crawler.on(event, function(item) {
            return _this.updateStatus(item, status);
          });
        };
      })(this);
      for (event in eventstates) {
        status = eventstates[event];
        setEventHandler(event, status);
      }
      query = {
        status: 'spooled',
        crawler: this.crawler.name
      };
      this.Item.update(query, {
        status: 'queued'
      }, {
        multi: true
      }, function(error) {
        if (error) {
          throw error;
        }
      });
    }

    MongoQueue.prototype.add = function(protocol, host, port, path, callback) {
      var count, data, hostParts, shortHost;
      callback = callback && callback instanceof Function ? callback : function() {};
      hostParts = host.split('.');
      shortHost = hostParts.length === 3 ? hostParts.slice(1, 3).join('.') : host;
      count = this.shortHosts[shortHost] || 0;
      if (count >= 10) {
        return callback(null, 0);
      } else {
        this.shortHosts[shortHost] = count + 1;
      }
      data = {
        protocol: protocol,
        host: host,
        port: port,
        path: path,
        crawler: this.crawler.name
      };
      return this.Item.findOne(data, (function(_this) {
        return function(error, item) {
          if (item) {
            item.set(data);
          } else {
            item = new _this.Item(data);
          }
          return item.save(callback);
        };
      })(this));
    };

    MongoQueue.prototype.exists = function(protocol, domain, port, path, callback) {
      var data;
      data = {
        protocol: protocol,
        domain: domain,
        port: port,
        path: path,
        crawler: this.crawler.name
      };
      return this.Item.count(data, callback);
    };

    MongoQueue.prototype.getLength = function(callback) {
      return this.Item.count({
        crawler: this.crawler.name
      }, callback);
    };

    MongoQueue.prototype.last = function(callback) {
      return this.Item.findOne({
        crawler: this.crawler.name
      }).sort({
        id: -1
      }).exec(callback);
    };

    MongoQueue.prototype.get = function(id, callback) {
      return this.Item.findById(id, callback);
    };

    MongoQueue.prototype.oldestUnfetchedItem = function(callback) {
      var query;
      query = {
        crawler: this.crawler.name,
        status: 'queued'
      };
      return this.Item.findOneAndUpdate(query, {
        status: 'spooled'
      }, callback);
    };

    MongoQueue.prototype.max = function(statisticname, callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.min = function(statisticname, callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.avg = function(statisticname, callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.complete = function(callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.countWithStatus = function(status, callback) {
      return this.Item.count({
        status: status,
        crawler: this.crawler.name
      });
    };

    MongoQueue.prototype.getWithStatus = function(status, callback) {
      return this.Item.find({
        status: status,
        crawler: this.crawler.name
      }, callback);
    };

    MongoQueue.prototype.errors = function(callback) {
      return this.Item.count({
        status: 'error',
        crawler: this.crawler.name
      }, callback);
    };

    MongoQueue.prototype.freeze = function(filename, callback) {
      return process.nextTick(function() {
        return callback(null);
      });
    };

    MongoQueue.prototype.defrost = function(filename, callback) {
      return process.nextTick(function() {
        return callback(null);
      });
    };

    return MongoQueue;

  })();

}).call(this);
