// Generated by CoffeeScript 1.9.0
(function() {
  var MongoQueue, getItem, _;

  _ = require("lodash");

  getItem = require("./QueueItem");

  module.exports = MongoQueue = (function() {
    function MongoQueue(mongo, db, _at_crawler) {
      var event, eventstates, query, setEventHandler, status;
      this.crawler = _at_crawler;
      console.log("Initializing mongo queue for " + this.crawler.name);
      this.hosts = db.get('hosts');
      this.Item = getItem(mongo, this.crawler.name);
      this.updateStatus = function(item, status) {
        item.set({
          status: status
        });
        return item.save(function(error) {
          if (error) {
            throw error;
          }
        });
      };
      eventstates = {
        fetchstart: 'spooled',
        fetchcomplete: 'fetched',
        fetcherror: 'error',
        fetchredirect: 'redirected'
      };
      setEventHandler = (function(_this) {
        return function(event, status) {
          return _this.crawler.on(event, function(item) {
            return _this.updateStatus(item, status);
          });
        };
      })(this);
      for (event in eventstates) {
        status = eventstates[event];
        setEventHandler(event, status);
      }
      query = {
        status: 'spooled',
        crawler: this.crawler.name
      };
      this.Item.update(query, {
        status: 'queued'
      }, {
        multi: true
      }, function(error) {
        if (error) {
          throw error;
        }
      });
    }

    MongoQueue.prototype.add = function(protocol, host, port, path, callback) {
      var data;
      data = {
        protocol: protocol,
        host: host,
        port: port,
        path: path,
        crawler: this.crawler.name
      };
      return this.Item.findOne(data, (function(_this) {
        return function(error, item) {
          if (item) {
            item.set(data);
          } else {
            item = new _this.Item(data);
          }
          return item.save(callback);
        };
      })(this));
    };

    MongoQueue.prototype.exists = function(protocol, domain, port, path, callback) {
      var data;
      data = {
        protocol: protocol,
        domain: domain,
        port: port,
        path: path,
        crawler: this.crawler.name
      };
      return this.Item.count(data, callback);
    };

    MongoQueue.prototype.getLength = function(callback) {
      return this.Item.count({
        crawler: this.crawler.name
      }, callback);
    };

    MongoQueue.prototype.last = function(callback) {
      return this.Item.findOne({
        crawler: this.crawler.name
      }).sort({
        id: -1
      }).exec(callback);
    };

    MongoQueue.prototype.get = function(id, callback) {
      return this.Item.findById(id, callback);
    };

    MongoQueue.prototype.bestHost = function(callback) {
      return this.Item.aggregate([
        {
          $match: {
            status: {
              $in: ['fetched', 'queued']
            }
          }
        }, {
          $group: {
            _id: {
              host: '$host',
              status: '$status'
            },
            total: {
              $sum: 1
            }
          }
        }, {
          $project: {
            _id: 0,
            host: '$_id.host',
            status: '$_id.status',
            total: 1
          }
        }
      ], function(error, replies) {
        var best, fetched, reply, totalFetched, _i, _len;
        best = null;
        for (_i = 0, _len = replies.length; _i < _len; _i++) {
          reply = replies[_i];
          if (reply.status === 'queued') {
            fetched = _.findWhere({
              status: 'fetched',
              host: reply.host
            });
            totalFetched = fetched ? fetched.total : 0;
            if (best === null || totalFetched < best.total) {
              best = reply;
            }
          }
        }
        return callback(best);
      });
    };

    MongoQueue.prototype.oldestUnfetchedItem = function(callback) {
      var query;
      query = {
        crawler: this.crawler.name,
        status: 'queued'
      };
      return this.bestHost((function(_this) {
        return function(best) {
          if (best) {
            query.host = best.host;
          }
          return _this.Item.findOneAndUpdate(query, {
            status: 'spooled'
          }, callback);
        };
      })(this));
    };

    MongoQueue.prototype.max = function(statisticname, callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.min = function(statisticname, callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.avg = function(statisticname, callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.complete = function(callback) {
      return process.nextTick(function() {
        return callback(null, 0);
      });
    };

    MongoQueue.prototype.countWithStatus = function(status, callback) {
      return this.Item.count({
        status: status,
        crawler: this.crawler.name
      });
    };

    MongoQueue.prototype.getWithStatus = function(status, callback) {
      return this.Item.find({
        status: status,
        crawler: this.crawler.name
      }, callback);
    };

    MongoQueue.prototype.errors = function(callback) {
      return this.Item.count({
        status: 'error',
        crawler: this.crawler.name
      }, callback);
    };

    MongoQueue.prototype.freeze = function(filename, callback) {
      return process.nextTick(function() {
        return callback(null);
      });
    };

    MongoQueue.prototype.defrost = function(filename, callback) {
      return process.nextTick(function() {
        return callback(null);
      });
    };

    return MongoQueue;

  })();

}).call(this);
